#!/usr/bin/env python3

'''
Required packages -

python3
opencv (and python bindings)
numpy

'''

import cv2 as cv
import time as time
import numpy as np


def make_gauss(centre, amp, sig, shapdim):

    '''just makes a Gaussian centred on chosen coordinates to
    use as the grav potential in the field'''

    sidelenx = shapdim[1]
    sideleny = shapdim[0]
    l = np.zeros(shapdim)

    for i in range(0, sideleny):

        for j in range(0, sidelenx):

            l[i, j] = np.sqrt((centre[0]-i)**2+(centre[1]-j)**2)

    gaussblob = amp*np.exp(-(l**2)/sig)
    return gaussblob


def calc_tranform(grad, lenx, leny):

    newxpos=np.zeros(lenx*leny, dtype=int)
    newypos=np.zeros(lenx*leny, dtype=int)

    index = 0

    for i in range(0, lenx):

        for j in range(0, leny):

            newxpos[index]=i-int(grad[0][i][j]) % lenx
            newypos[index]=j-int(grad[1][i][j]) % leny
            index+=1

    return (newxpos, newypos)


def main(cam_id):

    video_capture = cv.VideoCapture(cam_id)  # 0 - Default camera
    ret, frame = video_capture.read()
    rows, cols, ch = frame.shape
    gauss = make_gauss((rows/2, cols/2), 2000, 750, (rows, cols))
    grad = np.gradient(gauss)
    transpos = calc_tranform(grad, rows, cols)

    while True:
        # Capture frame-by-frame
        ret, frame = video_capture.read() # Capture Frame
        lensim = frame[transpos] # Apply Transform
        lensim = np.reshape(lensim, frame.shape) # Reshape back to 2D array
        result = cv.flip(lensim, 1) # Mirror
        cv.imshow('Video', result) # Display

        if cv.waitKey(1) & 0xFF == ord('q'):
            break

    # When everything is done, release the capture
    video_capture.release()
    cv.destroyAllWindows()


if __name__ == "__main__":

    print("\nLensface\n\nPress q to quit.")

    main(0)
